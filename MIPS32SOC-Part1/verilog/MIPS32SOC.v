/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule

module PriorityEncoder2 (
    input in0,
    input in1,
    input in2,
    input in3,
    output reg [1:0] num,
    output any
);
    always @ (*) begin
        if (in3 == 1'b1)
            num = 2'h3;
        else if (in2 == 1'b1)
            num = 2'h2;
        else if (in1 == 1'b1)
            num = 2'h1;
        else 
            num = 2'h0;
    end

    assign any = in0 | in1 | in2 | in3;
endmodule


module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module ControlUnit (
  input [5:0] Opcode,
  input Reset, // RESET input
  output aluSrc,
  output RegDst,
  output [2:0] aluOp,
  output memToReg,
  output memRead,
  output memWrite,
  output RegWrite
);
  wire s0;
  wire s1;
  wire s2;
  wire [1:0] s3;
  wire [8:0] s4;
  wire [8:0] s5;
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i0 (
    .a( Opcode ),
    .b( 6'b0 ),
    .\= ( s0 )
  );
  // SW
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i1 (
    .a( Opcode ),
    .b( 6'b101011 ),
    .\= ( s1 )
  );
  // LW
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i2 (
    .a( Opcode ),
    .b( 6'b100011 ),
    .\= ( s2 )
  );
  PriorityEncoder2 PriorityEncoder2_i3 (
    .in0( s0 ),
    .in1( s1 ),
    .in2( s2 ),
    .in3( 1'b0 ),
    .num( s3 )
  );
  Mux_4x1_NBits #(
    .Bits(9)
  )
  Mux_4x1_NBits_i4 (
    .sel( s3 ),
    .in_0( 9'b101111000 ),
    .in_1( 9'b10010001 ),
    .in_2( 9'b110010110 ),
    .in_3( 9'b0 ),
    .out( s4 )
  );
  Mux_2x1_NBits #(
    .Bits(9)
  )
  Mux_2x1_NBits_i5 (
    .sel( Reset ),
    .in_0( s4 ),
    .in_1( 9'b0 ),
    .out( s5 )
  );
  assign memWrite = s5[0];
  assign memRead = s5[1];
  assign memToReg = s5[2];
  assign aluOp = s5[5:3];
  assign RegDst = s5[6];
  assign aluSrc = s5[7];
  assign RegWrite = s5[8];
endmodule

module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module AsyncROM (
  input [7:0] addr,
  input en,
  output [31:0] dout
);
  reg [31:0] memory[0:255] /*verilator public*/;

  assign dout = en? memory[addr] : 32'hz;
  
  initial begin
`ifndef NO_INIT_MEM
    $readmemh("code.mif", memory, 0, 255);
`endif
  end
endmodule

module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule



module PriorityEncoder3 (
    input in0,
    input in1,
    input in2,
    input in3,
    input in4,
    input in5,
    input in6,
    input in7,
    output reg [2:0] num,
    output any
);
    always @ (*) begin
        if (in7 == 1'b1)
            num = 3'h7;
        else if (in6 == 1'b1)
            num = 3'h6;
        else if (in5 == 1'b1)
            num = 3'h5;
        else if (in4 == 1'b1)
            num = 3'h4;
        else if (in3 == 1'b1)
            num = 3'h3;
        else if (in2 == 1'b1)
            num = 3'h2;
        else if (in1 == 1'b1)
            num = 3'h1;
        else 
            num = 3'h0;
    end

    assign any = in0 | in1 | in2 | in3 | in4 | in5 | in6 | in7;
endmodule


module ALUControl (
  input [2:0] aluOp,
  input [5:0] Func,
  output [2:0] aluFunc
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire [2:0] s7;
  wire s8;
  wire [2:0] s9;
  wire s10;
  // ADD
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i0 (
    .a( Func ),
    .b( 6'b100000 ),
    .\= ( s0 )
  );
  // AND
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i1 (
    .a( Func ),
    .b( 6'b100100 ),
    .\= ( s1 )
  );
  // OR
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i2 (
    .a( Func ),
    .b( 6'b100101 ),
    .\= ( s2 )
  );
  // SUB
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i3 (
    .a( Func ),
    .b( 6'b100010 ),
    .\= ( s3 )
  );
  // SLT
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i4 (
    .a( Func ),
    .b( 6'b101010 ),
    .\= ( s4 )
  );
  CompUnsigned #(
    .Bits(3)
  )
  CompUnsigned_i5 (
    .a( aluOp ),
    .b( 3'b111 ),
    .\= ( s10 )
  );
  // BNE
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i6 (
    .a( Func ),
    .b( 6'b101 ),
    .\= ( s5 )
  );
  // BEQ
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i7 (
    .a( Func ),
    .b( 6'b100 ),
    .\= ( s6 )
  );
  PriorityEncoder3 PriorityEncoder3_i8 (
    .in0( s1 ),
    .in1( s2 ),
    .in2( s0 ),
    .in3( s3 ),
    .in4( s4 ),
    .in5( s5 ),
    .in6( s6 ),
    .in7( 1'b0 ),
    .num( s7 ),
    .any( s8 )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i9 (
    .sel( s8 ),
    .in_0( 3'b101 ),
    .in_1( s7 ),
    .out( s9 )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i10 (
    .sel( s10 ),
    .in_0( aluOp ),
    .in_1( s9 ),
    .out( aluFunc )
  );
endmodule

module RegisterFile(
    input [4:0] read_addr1,
    input [4:0] read_addr2,
    input [4:0] write_addr,
    input [31:0] write_data,
    input write_en,
    input clk,
    output [31:0] read_data1,
    output [31:0] read_data2
);

    reg [31:0] memory[0:31] /*verilator public*/;
    
    assign read_data1 = memory[read_addr1];
    assign read_data2 = memory[read_addr2];
    
    always @(posedge clk)
    begin
        if (write_en && write_addr != 5'd0)
            memory[write_addr] <= write_data;
    end

    initial begin
        memory[0] = 32'd0;
    end
endmodule


module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module CompSigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = $signed(a) > $signed(b);
    assign \= = $signed(a) == $signed(b);
    assign \< = $signed(a) < $signed(b);
endmodule


module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module ALU (
  input [31:0] a,
  input [31:0] b,
  input [2:0] op,
  output [31:0] res,
  output isZero
);
  wire [31:0] s0;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  wire [31:0] s4;
  wire [31:0] s5;
  wire [31:0] s6;
  wire [31:0] res_temp;
  wire s7;
  wire [31:0] s8;
  wire s9;
  wire s10;
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i0 (
    .a( a ),
    .b( b ),
    .c_i( 1'b0 ),
    .s( s0 )
  );
  DIG_Sub #(
    .Bits(32)
  )
  DIG_Sub_i1 (
    .a( a ),
    .b( b ),
    .c_i( 1'b0 ),
    .s( s1 )
  );
  assign s2 = (a & b);
  assign s3 = (a | b);
  // SLT
  CompSigned #(
    .Bits(32)
  )
  CompSigned_i2 (
    .a( a ),
    .b( b ),
    .\< ( s7 )
  );
  assign s8 = ~ a;
  // BEQ
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i3 (
    .a( a ),
    .b( b ),
    .\= ( s10 )
  );
  assign s4[0] = s7;
  assign s4[31:1] = 31'b0;
  // BNE
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i4 (
    .a( s8 ),
    .b( b ),
    .\= ( s9 )
  );
  assign s6[0] = s10;
  assign s6[31:1] = 31'b0;
  assign s5[0] = s9;
  assign s5[31:1] = 31'b0;
  Mux_8x1_NBits #(
    .Bits(32)
  )
  Mux_8x1_NBits_i5 (
    .sel( op ),
    .in_0( s2 ),
    .in_1( s3 ),
    .in_2( s0 ),
    .in_3( s1 ),
    .in_4( s4 ),
    .in_5( s5 ),
    .in_6( s6 ),
    .in_7( 32'b0 ),
    .out( res_temp )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i6 (
    .a( res_temp ),
    .b( 32'b0 ),
    .\= ( isZero )
  );
  assign res = res_temp;
endmodule

module RAMDualPort (
  input [7:0] addr,
  input [31:0] write_data,
  input mem_write,
  input clk,
  input mem_read,
  output [31:0] read_data
);
  reg [31:0] memory[0:255] /*verilator public*/;

  assign read_data = mem_read? memory[addr] : 32'hz;

  always @ (posedge clk) begin
    if (mem_write)
      memory[addr] <= write_data;
  end

  initial begin
`ifndef NO_INIT_MEM
    $readmemh("data.mif", memory, 0, 255);
`endif
  end
endmodule 


module MIPS32SOC (
  input clk,
  input rst,
  output invalid_opcode
);
  wire [31:0] s0;
  wire [31:0] s1;
  wire [7:0] s2;
  wire [31:0] s3;
  wire [31:0] s4;
  wire [9:0] s5;
  wire [31:0] s6;
  wire RegWrite;
  wire [4:0] s7;
  wire [4:0] s8;
  wire [4:0] s9;
  wire [31:0] s10;
  wire [31:0] s11;
  wire [5:0] Func;
  wire [4:0] s12;
  wire [5:0] Opcode;
  wire [31:0] s13;
  wire [2:0] aluFunc;
  wire [31:0] s14;
  wire [15:0] s15;
  wire [31:0] s16;
  wire aluSrc;
  wire RegDst;
  wire [2:0] aluOp;
  wire memToReg;
  wire memRead;
  wire memWrite;
  wire [7:0] s17;
  wire [31:0] s18;
  assign invalid_opcode = 1'b0;
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i0 (
    .sel( rst ),
    .in_0( s4 ),
    .in_1( 32'b0 ),
    .out( s0 )
  );
  ControlUnit ControlUnit_i1 (
    .Opcode( Opcode ),
    .Reset( rst ),
    .aluSrc( aluSrc ),
    .RegDst( RegDst ),
    .aluOp( aluOp ),
    .memToReg( memToReg ),
    .memRead( memRead ),
    .memWrite( memWrite ),
    .RegWrite( RegWrite )
  );
  reg [31:0] PC /*verilator public*/;
  assign s1 = PC;

  always @ (posedge clk) begin
    PC <= s0;
  end

  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i3 (
    .a( s1 ),
    .b( 32'b100 ),
    .c_i( 1'b0 ),
    .s( s4 )
  );
  assign s5 = s1[9:0];
  assign s2 = s5[9:2];
  // Inst_Mem
  AsyncROM inst_mem (
    .addr ( s2 ),
    .en ( 1'b1 ),
    .dout ( s3 )
  );
  assign Func = s3[5:0];
  assign s12 = s3[15:11];
  assign s9 = s3[20:16];
  assign s8 = s3[25:21];
  assign Opcode = s3[31:26];
  assign s15 = s3[15:0];
  DIG_BitExtender #(
    .inputBits(16),
    .outputBits(32)
  )
  DIG_BitExtender_i5 (
    .in( s15 ),
    .out( s16 )
  );
  Mux_2x1_NBits #(
    .Bits(5)
  )
  Mux_2x1_NBits_i6 (
    .sel( RegDst ),
    .in_0( s9 ),
    .in_1( s12 ),
    .out( s7 )
  );
  ALUControl ALUControl_i7 (
    .aluOp( aluOp ),
    .Func( Func ),
    .aluFunc( aluFunc )
  );
  // Reg File
  RegisterFile reg_file (
    .write_data ( s6 ),
    .write_en ( RegWrite ),
    .write_addr ( s7 ),
    .clk ( clk ),
    .read_addr1 ( s8 ),
    .read_addr2 ( s9 ),
    .read_data1 ( s10 ),
    .read_data2 ( s11 )
  );
  ALU ALU_i9 (
    .a( s10 ),
    .b( s13 ),
    .op( aluFunc ),
    .res( s14 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i10 (
    .sel( aluSrc ),
    .in_0( s11 ),
    .in_1( s16 ),
    .out( s13 )
  );
  // Data Mem
  RAMDualPort data_mem (
    .addr ( s17 ),
    .write_data ( s11 ),
    .mem_write ( memWrite ),
    .clk ( clk ),
    .mem_read ( memRead ),
    .read_data ( s18 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i12 (
    .sel( memToReg ),
    .in_0( s14 ),
    .in_1( s18 ),
    .out( s6 )
  );
  assign s17 = s14[9:2];
endmodule

